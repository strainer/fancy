#charges.n - draft todo notes for project - tail active

body affect functions, run after motion updates...
rigid body restore, runs after motion update, revises motion of embodied jotes contrasting with jotes previous motions, it may average them, it may calculate rotation, it may create or involve constraint & vibration notes for the body

grav functions need to tally accelerations for jotes, not to immediately update motions
jote.x jote.vx jote.ax jote.k 

jote.k may indicate mass details etc as well as kind 

jote.mass can be sparse array available to define unique mass vals for jotes of some kinds
sometimes jotes mass is implied by kind
jote.press can be sparse array defining a pressure analoge 


float64extraction scheme
fastest way to store multiple values in a javascript number (64 bits)-
 
color values are cast to float32 before renders, 
but preceeding operations must comply to 64float
so stored 32 floats will be cast before ops
can store as shared 64 bit float, involves 1 extraction cast and 2 mathops per
extraction

r=Math.rem(cl)
g=Math.rem(cl=(cl-r)*1024)
b=(cl-g)*1024

cl= r + g*1/1024 + b*1/1048576


r = cl
cl*=1024
g = cl-floor(cl)
cl*=1024


function puck(r,g,b)
  cl= (r-floor(r))*1024*1024 + (g-floor(g))*1024 + (b-floor(b))

function puckfst(r,g,b)
  cl= r*1024*1024 + g*1024 + b


function unpuck(cl)
  b= cl-floor(cl); cl=(cl-b)*1/1024
  g= cl-floor(cl); cl=(cl-g)*1/1024 
  r= cl-floor(cl)
  
This extracts 64 bit float to 3 0-1023 numbers, with minimum of casting away from 32 float



fitting integer prime fractions

a=n/(1023*1029)
 

kinds of jotes:
 grav include
 grav source
 static static
 static controlled
 bodie linked
 no radius
 small radius
 large radius
 has internal structure
 rendering details: fog, texture, plain etc.

other renderables:
 overlay

bodie linking
 link framework, linked to neighbours, linked to all, linked to center
 linked in skeleton form
 link types
  elastic bind
   elastic function
  angle bind
  
 
  
jote kinds
 without bodie
 


creating intresting model 
 have 4 gbodies
 
waiting to...
 make small clusters
  baseG
 make uplevel clusters
  upg[0]
 make uplevel clusters
  upg[1]
 
 use clusters to make accelerated multigbody
 use clusters to do collision
 
complication
  a collision update, can need to jump origin positions
  and ignore backtime interaction if/when updated course is retested
  it may retemper to remainder of tock?
  not retempering is however consistent with accepting the computational futility of
  sub tock refinement
  
10,000 travs /4 small clust ave size = 2500 small clusts
2500/10 ave size =250 
250/10 = 25 

//


developements to do...

improve keyboard controls,
flying option

indirect indexing of tacks by type, separate lists for involved behaviours
behaviors: 
 maj_gravity, min_gravity, chop_crush
 
 tack types 0 - free, 1-3 disabled/grav ignore ignore, 
 
model renderer by tack type info and static draft options/overlay/underlay

panel telemetry dash dom, modals, keyhelp, stats, controls 

basic group processing for maj_gravity
 20k split into groups approx 100 large - 200 groups
 calculates 
  group grav center 
  weight
  group bound (+sep?)
 
 group impulse tallied by (200x200)/2
 200 groups = 6*6*6
 each group contacts approx 26 neighbours= 1/10th of total groups

enhanced group processing


image the arrangement of 

jotes
 into wisps
jotes, unlinked or linked into a body

abody jotes
embodied jotes

jotes of a body
jotes of a part, loose part, tight part
parts of a thing

jotes within wisps

wisps within loci
 wisp maybe viewed as a jote
 
  //---------------
 
 #next physics scheme:
 
 shift position from t0 to t1, where mov relates +0.5t then -0.5t
 
 at t1, gravity is calculated in the tree
 then extracted from the tree and *applied to mov*
  -the application of accel to mov can be managed 
  with reference to bonded_groups and contact_mechanisms.
  
 mov then relates to +0.5t
 
 then treebounds are recalced for collision processing
 a collision list is generated
 for haste this list can be applied naively
 in time, 
  the earliest collision is played,
  altering spot bounds as necessary
   it is retested from playtime,
   and placed in list/queue again if re-hit
   the next collision is then played as neccessary...
   this is the secure collision requirement
   
 acceleration - has a list of contacting leaf spots for each leaf
 
 
 
 ephen.js - ecmascript physics engine
 
 versatile high quality physics processing for 
 virtual and real spacetime applications
 
 violet, viola, geola
 
 particulate based, bonds, mechanism
 
 
 
//----------------------------------
//

Things to do:

A new creation and alter....
 port existing functions to new scheme
  
 new alter system has insert.parms object
  with 
    insert x,y,x vx,vy,vz, number, basecolor, groupui, 
    
    insetpos(x,y,z)
    insetvel(vx,vy,vz)
    insetbasecol(r,g,b)
    insetgroup(g)
    insetorient(quaternion)
    
    addspinring(num,rad, raddist, spacing)
    addblob(num,rad, raddist, spacing)
    

stop playing df....

  concieving a game...
  drawing a self particle, pink/purple shimmering
   particle has velocity and mass like a normal jote
   particle may have collision detect /eat other particles
   
   need flying controls 
   - boost and retro, incremental on duration, scaled by local
     gravity
     
   need panels, display/disable on key press
    help panel
    detail panel - speed, local grav, nearest neighbour
    
   
   instructor
   chop > 
   
   atree
    bulkload
     builds a tree of 'spots' which recursively delineate the 
     positions and qualities of jotes
    updatebounds
     updates stored details of spots spatial bounds
    updateall 
     updates spots mass
     
     
     
    emptyaccel
   
    gravity
     nbodygravity
     rtreegravity

    multiply
    interply
    multifect
    interfect
    
    multicord
    intercord
    
//

nbodygrav_bulk
nbodygrav_map
nbodygrav_nearmap

collide_map

nbodyelectrograv_bulk

_map
 if nomap or badmapstat redo map
 
#name concept 
wherever 
 a general purpose 3d physics engine
 
 a library to run queries on physical models
 for real time following, interepreation and reaction to 
 sensor data.  
 
 droid control software which uses this engine can be
 developed and tested by simulated reality and sensor data
 hosted by this engine.
 
 'facsimilie server'
  figment server
 scenation server
 scenation server
 lucination js
 lucinogen js
 hallucene
 
 luc,illusion, allusion, hallucination
 
 provident
 providere js - to see forward
 
 phantasm, phantasmagoria
 
 fantasia,phyntasm,fanta js
 fancy enfancy
 
 halluciflex,halflex
 spacebase,matterbase
 basefancy
 nalspace
 premonition
 premonitor
 simagine
 bulker
 fanbulk
 forestance
 physter
 fancy 
 
# Fancy fellicitous physics function for friendly futuroids 

Figment  physics functions for futuroids

codebase terminology:
 
 figm - a figment: a running model instance 
 jote - particles|iota of model detail
 spotmap - data tree addressing jotes in recursively nested boxes|spots
   
 naturals.js - actions like gravitation, friction, bonds, movement
 paranormals.js - actions like... add, destroy...
   
 helpers.js - framework and demo source helper functions
 
 instructor.js (becomes initbench)
 
 according to gplay:
  inits creation of model
  
  inits viewport controller

  inits keysys for viewport/s to 
   keysys for over
   
   run update functions which the guiding viewport calls
   ( non-guiding/ambient viewports are possible ) 
   
#mess here

.gitignore
licence
readme.md
index.html

\bench
 qpane
 threeset
 creations
 showbench
 
\figment
 base , helper, alter ,tree, measure, natural, paranorm

\ext
 fdrandom three
  
\drafts 
\doc
 

how to arrange....

 fancy library:
  new figment
  alter functions
  etc..
   
 bench framework
  index
  pre_init
  
  loaddefaults:
   fplay contains all bench making vars
   creation.js contains constructors for scenarios
    on figments with keysys
   keysys
  viewport   
  keysys
  
  viewport/figm progress loop/s
  
  bendat - viewport & figm init and run data:
   
# instructor becomes benchmain
  
   object
   benfo (gplay)
    figm
     jote
     bond
     face 
  
   functions
   
    figm creation,
    qpanels creation
    play_process_loop
     nat_process   
     para_process
    keysys

  
  
  current instructor is a little cludgey but working efficiently because
  
  
//------------

 index.html 
 
 viewserve.js
 
 helpers.js
 base.js
 alter.js
 //insert.js
 creations.js
 
 paranormals.js
 naturals.js
  linkages
  stressholds
  impactsurfaces
  exception listing
 
 measures.js
  makes and maintains and updates a spotmap of jtspace
   make new spotmap
   resolve spot bounds for grav (space)
   resolve spot bounds for coll (space by time interval)
    log spot bound efficiencies while resolving, 
     for triggering remakes or rearrangement of spotoak
     
  querie all jote in area - sphere, cuboid, cylinder
  all jote contacting anothers travel
 
 query
  might backup, run, measure a model, to discern things
   like average distance between two jots
   or destination of jot
   
 actionschedules.js
  nbody influence (gravity, elstatic)
 
  spotbody influence (sparse cluster grav, elstat)
  
  map collision detect and queue
  collision responses
  
   



space time or
time space


rate of progression of property change at present position
= full rate - rate of progression of movement to adjacent position

movement is progression of property to adjacent position
particulation is packetisation phenomenon of localised property

location context map


gravity, location of matter unifies if it is not held separate by travel
to be near in space is to grow nearer in space through time
that is spatial attraction


//-----------
Issue that was to be done:

upload fancy to git:
sanitise fancy files and make presentable the readmes

fancy developements: 
  swipe control
  remake qpane
   sphere renderer
   fps readout
   github div slider
  
Inspection of repo structure
 gh-pages branch is nested into master
 i must commit dev to master, for visibility
 copy to gh-pages and commit gh-pages
 but must dev in gh-pages to get it basic working
 before copying to master for standard deving
 dev as much in master as possible and script.cp to gh-pages