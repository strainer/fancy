    aspects of the vtree  ways to alter the tree  a new vox and its associates (spatialy bounded contents)  could be placed on the end of the dlsq, but it could only be attached  to the last sibling,  given the same parent as the vox at the end of the dlsq  which could have been placed their as an empty  empty voxes may have potential use,  but placing a vox into the tree requires shifting the above dlsq  and updating dln pointers in following vxnode records  the node records need the ability to refer directly to dlsq?  perhaps not, only final level voxes dlsq is actively used    a crafty recursive function would be required to list all jotes  of a midvox, but it would not be greatly..time consuming, perhaps 10 or more times   slower than reading from the dlsq, well except if the whole tree had to be traversed from the root...    but under what designments would jote access of a midvex be appropriate?    as vexels have a quality of non consumptiveness  they are sought to fit area from the root  the root maps occupancy may overlap, so all cells of a roots  mapping must be checked for fits      ///--  // outspots < spots > inspots > jotes  ///--    algorithms for accelerated calculation of physical developements    given a collection of atomic details of matter  where each atom is in effect one undivided iota of material detail  minimum information of each iota consists of:    its place (x,y,z), its movement (x,y,z) by dt      additional information may include    mass, charge, heat, linkages, mechanism based holding adjustment     such values may be connoted by a 'type' attribute    here, a collection/store/database of such information is coined 'jote' (iota sic)    in physical extrapolation matter is separated by distance,  which is cabable of carrying distance effects of decreasing intensity  and is capable of increasing or reducing by time bounded space travel      interference between matter is diminished in intensity or frequentness  by interval distance     distance effect adjustments such as gravity and feild effects,  and contact interactions require many comparisons of all matters position    to accelerate spatial comparisons and make approximations, an ability to  correlate groups of jotes is required...    A 'r-tree' like reference map of local matter groups is designed  to serve spatial queries. The reference employs a sorted-by-node   indirect index, coined as 'delineation sequence' to simplify and reduce  memory overhead of internal node referencing. Each tree node has one  pointer to the start of its line of set in the dlnsq:    11111111111111111   structure of sui  22333333344455555  67889999abbcddeef    ghijjj    klmn       opp         qr      111 11111 11      222 33333 44    012 34567 89 - dlnsi (delineation sequence index)  566 77888 99    ade himno st - delineation sequence contents     node:1  dlnsi_anchor:0  parent_node:0  first_child:2  set:adehimnost    node:2  dlnsi_anchor:0  parent_node:1  first_child:5  set:ade  node:3  dlnsi_anchor:3  parent_node:1  first_child:7  set:himno  node:4  dlnsi_anchor:8  parent_node:1  first_child:9  set:st            node:5  dlnsi_anchor:0  parent_node:2  first_child:0  set:a  node:6  dlnsi_anchor:1  parent_node:2  first_child:0  set:de            node:7  dlnsi_anchor:3  parent_node:3  first_child:0  set:hi    node:8  dlnsi_anchor:5  parent_node:3  first_child:0  set:mno            node:9  dlnsi_anchor:8  parent_node:4  first_child:0  set:st  node:10 dlnsi_anchor:10 parent_node:0  first_child:0  set:[end marker]    dlnsi_anchor determines where a nodes ref-set begins in dln-sequence  dlnsi_end may ommitted as leaf nodes can be assured to end at   the anchor of the very next node. since leaf nodes have no children.     internal (non-leaf) nodes end at the anchor of the next non-offspring node.  dlnsi_end could be useful to have stored at hand, however  node-tree adjustments can be made almost twice as quickly  without it.      last_child ref could increase searchability?    the dln_anchors and parent_nodes are writeable during the recursive   sorting-subsorting creation of the dlnsq.  The first_child node attribute of nodes are written on a second pass,   while computing each nodes true spatial bounds, which is cascading  from the deepest level nodes to the root.    With this tree referencing scheme, employing a dln-sequence  the jotes are subdivided from the full root group, into smaller and smaller  groups organised by their position into subsectors which imply their subgroups    these groups are coined 'spots' in this code    the root spot has bounds which extend to the farthest positions of jotes    the bounds of the root spot is the first major computational step in  creating the location-tree reference structure     knowing the measurement of a spots bounds, and the number of jotes which the spot  contains, it is possible to define subdivision of the bounds likely to divide  it most advantageously, for later computational purposes.    a root spot is expected capable of spanning thousands of jotes  whereas an end spot should not be much more than a dozen jotes and may contain  a single remote, or fast moving jote.    several layers of subdivision are arranged between a root and its ends  there may be later computational disefficiencies if a spot contains  too many child spots,    the memory/computational overhead of small spotting is minimised by the dlsq-tree scheme.    computing with the dlsq rather than on sparsely occupied reference bins allocated  to nodes, seems convienient and quick at least during creation of the trindex     post creation, when nodes are moved, anchor pointers of all subsequent nodes  will need adjusted. this maintenence may limit applications of the scheme, andor  beg extra scheming for dln_pointer maintenance.    this tree ref is supposed to quickly/roughly cluster jotes and spots of jotes,   which tend to move and make the bounds of allocated spots ballon over time.  maintenance operations are expected to include, measurement of spot balloning  guiding targeted recomposition of large spots, and removal of most errant jotes  from leaves.  Aside from rough-quick recomposition, errant jotes and spots may not seek to be  reinserted most fittingly, instead may be tacked onto end.    every timeslice,    the spacetree ref wants partially recreated, andor pruned,purged   instant bounds calculated for feild effect adjustment    feild effect is then applied   time-movement masked bounds are calculated for contact percussion resolution    contact percussions are applied, updating time-movement bounds as-go      these are fairly modest O(n) processes applied to records of 10s thousands  assisting modest O(n*n) raw process, to achieve nlogn time with approximations.   the maintence and recalculations on the tree are fast compared to the recursive   work done with it.      in the common case that the following spot is a sibling  its dln anchor must be the end of the preceeding siblings dln span  the ids of the spots are created to run sequentially through siblings  however after a 'sibling_run' following spot may jump backward in dln,  it may jump to the first child of the sibling_run    spot 01     spot 02   spot 03   spot 04            sp05   e06  sp13 sp14            s7  s8         e9e10 e11 e12    the spot id ordering, always decends into latest sibruns ancenstors  and only jumps up to most recent undissolve sib run    a way to figure out the end of a spots dln span  is find the anchor of its parents little-sib  or the anchor of the first little sib of its ancestor    also kid anchor can preceed the previous  anchor if next, - is focus of next spot  leaps in memory chunks  so here, allocate length of cell  length can be used to shrink cells, not  expand unless preshrunk?      the distance effect process:    proceed(spot):   list its subspots   crossmate each subspot with other   proceed(each subspot)    crossmate(spota,spotb),   note size of each spot   note distance between   note weight      if maxsize/distance*weight>factor consumate directly   else make 2 lists of subspots (break down both or a single larger spot)   crossmate each combination       #things i want to do with the tree... delete node add node supersort node determine best leaf size, best internal size, determinne a policy for partial, incremental tree maintainence make a panel, a hidden div, in which tree measurements can be displayed  desired measurements of the tree:  sum bound volume of all spots  average bound volume of leaf spots  average reduction volume of upspots/inspots  percentage of spots at depth  #early developement policy of tree now that bulk_loading has been achieved, it can be used naively by repetition, without tree editing/optimisation it can be refreshed every n frames.  n-frame tree refresh and reuse policy  the actual opportunities for tree optimisation involve possibly vaste reflection on the qualities of the tree  the bulk_loaded tree is sufficient for basic but significant, search ->*process_ordering* use. it can be editted with integration of an extra pointer the case of splitting the bulk into separately indexed trees which can be refreshed atomicly is also interesting.  however the basic bulk_loaded tree is ready to be tested...    #about the static tree the tree is navigated with occassional fchild lookups (1/ave spotsize) and parent lookup (1 per every spot), extra prt and fch lookups at fam-end, usually 1 p&f, eg.25%  5% 2p&f 1% 3p&f the datum for these lookups is 1p and 1f value per spot  1 dln value also exists per spot to store associates###spotmap.js[Live view](https://strainer.github.io/fancy#09pau_spots "Demo")The 'spotmap' is an example of a "B-tree class" data stucture which indexes items (and its own indexes) by nested relations in multiple dimensions.* The details of the spotmap allow fast query of all items withinsome distance of another item or location.* Spotmap allows fast discovery of the particular 'spots' which particular items are present in. (All items are present in the root spot, in trunkand branch spots and in a final leaf spot)* Spotmap allows fast traversal of the heirarchy of all spots (each spots parent_spot and child_spots can be quickly discerned)These indexing options (for indexing items and spot-relations by space and index) are implemented with:  1. One sorted list of all items:  * `delineation_sequence[item_ix]      //a list of item indexes` 2. one collection of spot records:  * `spot.dln_anchor[spot_ix]  //start of spots items in delin_seq`  * `spot.dln_span[spot_ix]    //number of spots items (optional) `  * `spot.parent[spot_ix]      //ix of parent spot                `  * `spot.firstchild[spot_ix]  //ix of first child spot           `	 These 5 arrays of fixed size are enough to convieniently encodeany viable heirarchy of spots -any spot can link any number ofchild spots and items.Each spot also has computed and stored spatial bounds (high and low)and total mass and center of mass. These details are computedafter 'loading' the tree (creating a fresh heirarchy) and are refreshedin use.####Visualisation of Spot index heirarchyChart of spot indices over the delin_seq and nest-levelpertaining to 75 items (across) indexed by 61 spots```/-----------------length of delin_seq and total items---------------------/111111111111111111111111111111111111111111111111111111111111111111111111111222223333333333344555555556666666777777777777777777778888889999aaaaaaaaaabbcddddghhhhhhhiii  opppppppuvvvvwxAAABBBCCCCCCCDDDEFGGLLLLLMRRSSTTTTTTTTUU   eeff jjkllll      qqqqqrr yyyz        HHHIIII       NOOOO     VVVVVWWX             mmnn      ssstt                  JKKK        PPQQ     YYYZZ       ```Notes* Root spot '1' includes all items.* The indices of the spots *under* any spot (trunk) form a single unbroken sequence, starting with the trunks firstchild index, ending on the last spotwhich does not have trunk as an ancestor - (or the last whose parent isa sibling of the trunk or some other quick trick...)Knowing the unbroken index-range under any spot, it is possible to 'reload' spots, with upto the same number child spots.If less spot_indices are used, the parent and kid si of unused can be invalidatedIf more spot_indices are necessary, extra gap in the si-sequence can be madewith a simple back-travelling shift of all spots elements and adjustment of their child and parent values which are after thegap range.//-----------1 root spot8 trunk spots arranged by speed + spaceie 8 equal sized trunk spots012 3456701 23 456701 2 34 567current state of spotmap,topcell creationdigest - survey digest 